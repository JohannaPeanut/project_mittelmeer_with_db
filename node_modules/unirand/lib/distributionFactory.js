"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Factory method for creation random distributed methods
 * Created by Alexey S. Kiselev
 */
var distributionMethods = require(__dirname + '/methods');

var RandomFactory = /*#__PURE__*/function () {
  function RandomFactory() {
    _classCallCheck(this, RandomFactory);

    this._distributions = {};
  }
  /**
   * Sets current generator
   */


  _createClass(RandomFactory, [{
    key: "set_current_generator",
    value: function set_current_generator(method) {
      var _this$_current_method;

      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      if (!this._distributions[method]) {
        var Method = distributionMethods[method];
        this._distributions[method] = _construct(Method, params);
      }

      this._current_method = this._distributions[method];

      (_this$_current_method = this._current_method).refresh.apply(_this$_current_method, params);
    }
    /**
     * Required method
     * Method .random(): Promise<number> generates a random number due to distribution
     * This method is asynchronous, contains method .then(data: number => {}) and
     * .catch(err: {error: string} => {}) corresponds to error in random distribution
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns a random number on each call, can be integer or float
     */

  }, {
    key: "random",
    value: function random() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (_this.isError().error) {
            reject(_this.isError());
          } else {
            resolve(_this._current_method.random());
          }
        }, 0);
      });
    }
    /**
     * Required method
     * Method .next(): Promise<number> generates a next seeded random number due to distribution
     * This method is asynchronous, contains method .then(data: number => {}) and
     * .catch(err: {error: string} => {}) corresponds to error in random distribution
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns a random number on each call, can be integer or float
     */

  }, {
    key: "next",
    value: function next() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (_this2.isError().error) {
            reject(_this2.isError());
          } else {
            resolve(_this2._current_method.next());
          }
        }, 0);
      });
    }
    /**
     * Required method
     * Method .randomSync(): number generates a random number due to distribution
     * This method is synchronous
     * Produces a random number or throw an error message
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns a random number on each call, can be integer or float
     */

  }, {
    key: "randomSync",
    value: function randomSync() {
      if (this.isError().error) {
        throw new Error(this.isError().error);
      }

      return this._current_method.random();
    }
    /**
     * Required method
     * Method .nextSync(): number generates a seeded next random number due to distribution
     * This method is synchronous
     * Produces a random number or throw an error message
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns a random number on each call, can be integer or float
     */

  }, {
    key: "nextSync",
    value: function nextSync() {
      if (this.isError().error) {
        throw new Error(this.isError().error);
      }

      return this._current_method.next();
    }
    /**
     * Required method
     * Method .distribution(n: number): Promise<Array<number>> generates an array of random numbers due to distribution
     * Contains n (n > 0) random distributed numbers. By default n = 10
     * Can contains additional parameters for formatting purposes
     * This method is asynchronous, contains method .then(data: Array<number> => {}) and
     * .catch(err: {error: string} => {}) corresponds to error in random distribution
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns an array of random numbers on each call, numbers can be integer or float
     */

  }, {
    key: "distribution",
    value: function distribution() {
      var _this3 = this;

      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      for (var _len2 = arguments.length, distParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        distParams[_key2 - 1] = arguments[_key2];
      }

      if (n < 1) {
        n = 1;
      }

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (_this3.isError().error) {
            reject(_this3.isError());
          } else {
            var _this3$_current_metho;

            resolve((_this3$_current_metho = _this3._current_method).distribution.apply(_this3$_current_metho, [n].concat(distParams)));
          }
        }, 0);
      });
    }
    /**
     * Required method
     * Method .distributionSync(n: number): Array<number> generates an array of random numbers due to distribution
     * Contains n (n > 0) random distributed numbers. By default n = 10
     * Can contains additional parameters for formatting purposes
     * This method is synchronous. Produces an array of random numbers or throw an error message
     * Error can occurs with incorrect input values, served by .isError() method
     * @returns an array of random numbers on each call, numbers can be integer or float
     */

  }, {
    key: "distributionSync",
    value: function distributionSync() {
      var _this$_current_method2;

      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      if (n < 1) {
        n = 1;
      }

      if (this.isError().error) {
        throw new Error(this.isError().error);
      }

      for (var _len3 = arguments.length, distParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        distParams[_key3 - 1] = arguments[_key3];
      }

      return (_this$_current_method2 = this._current_method).distribution.apply(_this$_current_method2, [n].concat(distParams));
    }
    /**
     * Required method
     * Method .isError(): boolean | {error: string} checks whether an error occurs in random method due to incorrect input values
     * This method is synchronous.
     * @returns "false" if no error occurred
     * or {error: string} object with error message if error occurred
     */

  }, {
    key: "isError",
    value: function isError() {
      return this._current_method.isError();
    }
    /**
     * Required method
     * Method .refresh(..params): void change th input values in existing distribution without creating new instance
     * Input parameters must be the same as in constructor
     * In this method .isError will refreshes too
     * Examle usage:
     * let normal = randomjs.normal(1, 2);
     * normal.random() // will generate random numbers with Gaussian distribution with mu = 1 and sigma = 2
     * normal.refresh(3, 4);
     * normal.random() // will generate random numbers with Gaussian distribution with mu = 3 and sigma = 4
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this$_current_method3;

      (_this$_current_method3 = this._current_method).refresh.apply(_this$_current_method3, arguments);
    }
    /**
     * class .toString() method, which will output information about distribution
     * @returns string
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._current_method.toString();
    }
  }]);

  return RandomFactory;
}();

var _default = RandomFactory;
exports["default"] = _default;