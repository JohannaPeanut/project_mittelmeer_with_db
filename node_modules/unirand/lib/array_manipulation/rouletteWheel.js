"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _prngProxy = require("../prng/prngProxy");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RouletteWheel = /*#__PURE__*/function () {
  function RouletteWheel(weights) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, RouletteWheel);

    this._validate(weights);

    this._w_max = this._getMaxWeight(weights);
    this._weights = weights; // does not mutate original weights array, it is safe

    this._w_length = weights.length;
    this._prng = new _prngProxy.PRNGProxy();

    if (this._isDefined(options.seed)) {
      this.seed(options.seed);
    }

    this.setPrng(this._isDefined(options.prng) ? options.prng : _prngProxy.DEFAULT_GENERATOR, true);
  }
  /**
   * Check whether option is defined
   * @param {any} option
   * @private
   */


  _createClass(RouletteWheel, [{
    key: "_isDefined",
    value: function _isDefined(option) {
      return option !== null && typeof option !== 'undefined';
    }
    /**
     * Validate weight array
     * @param {any} weights
     * @private
     */

  }, {
    key: "_validate",
    value: function _validate(weights) {
      if (!Array.isArray(weights)) {
        throw new Error('RouletteWheel: weights must be array');
      }

      if (weights.length < 1) {
        throw new Error('RouletteWheel: weights array must contain at least one element');
      }

      for (var i = 0; i < weights.length; i += 1) {
        if (typeof weights[i] !== 'number' || weights[i] <= 0) {
          throw new Error('RouletteWheel: weights must be a positive numbers');
        }
      }
    }
    /**
     * Calculates max weight
     * @param {Array<number>} weights
     * @private
     */

  }, {
    key: "_getMaxWeight",
    value: function _getMaxWeight(weights) {
      var _max = -Infinity;

      for (var i = 0; i < weights.length; i += 1) {
        if (weights[i] > _max) {
          _max = weights[i];
        }
      }

      return _max;
    }
    /**
     * Return random index of weights array
     * @private
     */

  }, {
    key: "_getRandomWeightIndex",
    value: function _getRandomWeightIndex() {
      return Math.floor(this._prng.next() * this._w_length);
    }
    /**
     * In case of using seeded PRNG reset prng to initial state
     * @public
     */

  }, {
    key: "reset",
    value: function reset() {
      this._prng.random();
    }
    /**
     * Set seed value for local PRNG
     * @param {NumberString} seed_value
     * @public
     */

  }, {
    key: "seed",
    value: function seed(seed_value) {
      this._prng.seed(seed_value);
    }
    /**
     * Set local PRNG algorithm
     * @param {string} prng_name
     * @param {boolean} reset - whether reset PRNG state for new one or not
     * @public
     */

  }, {
    key: "setPrng",
    value: function setPrng(prng_name) {
      var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._prng.set_prng(prng_name);

      if (reset) {
        this.reset();
      }
    }
    /**
     * Select random element due to weights
     * @public
     */
    // $FlowFixMe - will be always accepted as weights are validated, number will ba always returned

  }, {
    key: "select",
    value: function select() {
      /* eslint-disable no-constant-condition */
      while (true) {
        var _index = this._getRandomWeightIndex();

        if (this._prng.next() < this._weights[_index] / this._w_max) {
          return _index;
        }
      }
    }
  }]);

  return RouletteWheel;
}();

var _default = RouletteWheel;
exports["default"] = _default;