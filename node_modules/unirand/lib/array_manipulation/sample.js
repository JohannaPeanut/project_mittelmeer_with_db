"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _base = _interopRequireDefault(require("./base"));

var _shuffle = _interopRequireDefault(require("./shuffle"));

var _prngProxy = _interopRequireDefault(require("../prng/prngProxy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Sample = /*#__PURE__*/function (_ArrayManipulation) {
  _inherits(Sample, _ArrayManipulation);

  var _super = _createSuper(Sample);

  function Sample() {
    var _this;

    _classCallCheck(this, Sample);

    _this = _super.call(this);
    _this._shuffle = new _shuffle["default"]();
    return _this;
  }

  _createClass(Sample, [{
    key: "getSample",
    value: function getSample(input, k) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        shuffle: false
      };
      var result;

      this._validateInput(input); // if k is undefined - returns a sample with random size (including [])


      if (typeof k === 'undefined') {
        if (typeof input === 'string') {
          result = this._getSampleRandomSizeForString(input);
        } else if (Array.isArray(input)) {
          result = this._getSampleRandomSizeForArray(input);
        } else {
          result = this._getSampleRandomSizeForObject(input);
        }

        if (options.shuffle && !(_typeof(input) === 'object' && !Array.isArray(input))) {
          return this._shuffle.getPermutation(result);
        }

        return result;
      }

      if (typeof k !== 'number' || k <= 0) {
        throw new Error('Sample: "k" must be positive integer');
      }

      if (k >= input.length) {
        if (options.shuffle && !(_typeof(input) === 'object' && !Array.isArray(input))) {
          return this._shuffle.getPermutation(input);
        }

        return input;
      } // For performance purposes I am going to separate sampling methods for different types


      if (typeof input === 'string') {
        if (k / input.length <= 0.2) {
          result = this._getHijenhuisWilfSampleForString(input, k);
        } else {
          result = this._getSampleForString(input, k);
        }
      } else if (Array.isArray(input)) {
        if (k / input.length <= 0.125) {
          result = this._getHijenhuisWilfSampleForArray(input, k);
        } else {
          result = this._getSampleForArray(input, k);
        }
      } else {
        result = this._getSampleForObject(input, k);
      }

      if (options.shuffle && !(_typeof(input) === 'object' && !Array.isArray(input))) {
        return this._shuffle.getPermutation(result);
      }

      return result;
    }
    /**
     * Random sample with random size (including [])
     * @param inputArr: Array
     * @returns {RandomArrayNumberString<number|string>}
     * @private
     */

  }, {
    key: "_getSampleRandomSizeForArray",
    value: function _getSampleRandomSizeForArray(inputArr) {
      var temp,
          j = 0,
          result = [];

      _prngProxy["default"].random();

      for (var i = 0; i < inputArr.length; i += 1) {
        temp = Math.floor(2 * _prngProxy["default"].next());

        if (temp === 1) {
          result[j] = inputArr[i];
          j += 1;
        }
      }

      return result;
    }
    /**
     * Random sample with random size (including '')
     * @param inputArr: string
     * @returns string
     * @private
     */

  }, {
    key: "_getSampleRandomSizeForString",
    value: function _getSampleRandomSizeForString(inputStr) {
      var temp,
          result = '';

      _prngProxy["default"].random();

      for (var i = 0; i < inputStr.length; i += 1) {
        temp = Math.floor(2 * _prngProxy["default"].next());

        if (temp === 1) {
          result += inputStr[i];
        }
      }

      return result;
    }
    /**
     * Private getSample method for objects
     * O(k) in memory, O(n) in time
     * @param input: RandomArrayNumberString<number | string>
     * @param k: number
     * @private
     */

  }, {
    key: "_getSampleRandomSizeForObject",
    value: function _getSampleRandomSizeForObject(input) {
      var result = {},
          keys = Object.keys(input),
          temp;

      _prngProxy["default"].random();

      for (var i = 0; i < keys.length; i += 1) {
        temp = Math.floor(2 * _prngProxy["default"].next());

        if (temp === 1) {
          result[keys[i]] += input[keys[i]];
        }
      }

      return result;
    }
    /**
     * Improved sampling with O(n + k) in memory and O(k) in time
     * It makes sense only for shuffled results
     * By statistics - it is faster then _getSampleForArray method only for k <= n / 2
     * @param inputArr: Array
     * @param k: number
     * @returns {RandomArrayNumberString<number|string>}
     * @private
     */

  }, {
    key: "_getSampleImprovedForArray",
    value: function _getSampleImprovedForArray(inputArr, k) {
      var input = inputArr.slice(),
          n = input.length,
          ni = n,
          r = -1,
          result = [],
          m = 0; // elements in result

      _prngProxy["default"].random();

      while (m < k) {
        r = Math.floor(_prngProxy["default"].next() * ni);
        result[m] = [r, input[r]];
        m += 1; // swap chosen element and last element

        ni -= 1; // $FlowFixMe - Destructuring swap is faster

        var _ref = [input[ni], input[r]];
        input[r] = _ref[0];
        input[ni] = _ref[1];
      }

      return result;
    }
    /**
     * Hijenhuis & Wilf algorithm for indexes
     * Improved sampling with O(k) time complexity
     * Does not mutate original array
     * @param n: number - number of elements in array or string
     * @param k: number
     * @returns {RandomArray} - array with random indexes shifted by one to the right
     * @private
     */

  }, {
    key: "_getHijenhuisWilfSampleIndexes",
    value: function _getHijenhuisWilfSampleIndexes(n, k) {
      var c,
          a = [],
          x,
          l,
          i,
          p,
          s,
          temp,
          delta_s,
          r,
          m0,
          m;

      _prngProxy["default"].random(); // 1 - O(k) complexity


      for (var idx = 0; idx < k; idx += 1) {
        a[idx] = Math.floor(idx * n / k);
      }

      c = k; // 2

      while (c > 0) {
        x = 1 + Math.floor(_prngProxy["default"].next() * n);
        l = 1 + Math.floor((x * k - 1) / n);

        if (x > a[l - 1]) {
          a[l - 1] += 1;
          c -= 1;
        }
      }

      i = 0;
      p = 0;
      s = k; // 3 - O(k) complexity

      while (i < k) {
        i += 1;

        if (a[i - 1] === Math.floor(n * (i - 1) / k)) {
          a[i - 1] = 0;
          continue;
        }

        p += 1;
        temp = a[i - 1];
        a[i - 1] = 0;
        a[p - 1] = temp;
      } // 4


      while (p > 0) {
        l = 1 + Math.floor((a[p - 1] * k - 1) / n);
        delta_s = a[p - 1] - Math.floor((l - 1) * n / k);
        a[p - 1] = 0;
        a[s - 1] = l;
        s -= delta_s;
        p -= 1;
      }

      l = k; // 5

      while (l > 0) {
        if (a[l - 1] > 0) {
          r = l;
          m0 = 1 + Math.floor((a[l - 1] - 1) * n / k);
          m = Math.floor(a[l - 1] * n / k) - m0 + 1;
        } // $FlowFixMe


        x = m0 + Math.floor(_prngProxy["default"].next() * m);
        i = l; // eslint-disable-next-line no-constant-condition

        while (true) {
          i += 1; // $FlowFixMe

          if (i > r || x < a[i - 1]) {
            break;
          }

          a[i - 2] = a[i - 1];
          x += 1;
        }

        a[i - 2] = x; // $FlowFixMe

        m -= 1;
        l -= 1;
      }

      return a;
    }
    /**
     * Private getSample method (Hijenhuis & Wilf algorithm) for arrays
     * @param input: RandomArrayNumberString<number | string>
     * @param k: number
     * @private
     */

  }, {
    key: "_getHijenhuisWilfSampleForArray",
    value: function _getHijenhuisWilfSampleForArray(input, k) {
      // for arrays
      var result = [],
          n = input.length,
          indexes = this._getHijenhuisWilfSampleIndexes(n, k);

      for (var idx = 0; idx < k; idx += 1) {
        result[idx] = input[indexes[idx] - 1];
      }

      return result;
    }
    /**
     * Private getSample method (Hijenhuis & Wilf algorithm) for strings
     * @param input: string
     * @param k: number
     * @private
     */

  }, {
    key: "_getHijenhuisWilfSampleForString",
    value: function _getHijenhuisWilfSampleForString(input, k) {
      // for strings
      var result = '',
          n = input.length,
          indexes = this._getHijenhuisWilfSampleIndexes(n, k);

      for (var idx = 0; idx < k; idx += 1) {
        result += input[indexes[idx] - 1];
      }

      return result;
    }
    /**
     * Private getSample method for arrays
     * O(k) in memory and O(n) in time
     * @param input: RandomArrayNumberString<number | string>
     * @param k: number
     * @private
     */

  }, {
    key: "_getSampleForArray",
    value: function _getSampleForArray(input, k) {
      // for arrays
      var result = [],
          n = input.length,
          t = 0,
          // total elements
      m = 0; // selected elements

      _prngProxy["default"].random();

      while (m < k) {
        if ((n - t) * _prngProxy["default"].next() < k - m) {
          result[m] = input[t];
          m += 1;
        }

        t += 1;
      }

      return result;
    }
    /**
     * Private getSample method for arrays
     * O(k) in memory, O(n) in time
     * @param input: string
     * @param k: number
     * @private
     */

  }, {
    key: "_getSampleForString",
    value: function _getSampleForString(input, k) {
      // for strings
      var result = '',
          n = input.length,
          t = 0,
          // total elements
      m = 0; // selected elements

      _prngProxy["default"].random();

      while (m < k) {
        if ((n - t) * _prngProxy["default"].next() < k - m) {
          result += input[t];
          m += 1;
        }

        t += 1;
      }

      return result;
    }
    /**
     * Private getSample method for objects
     * O(k) in memory, O(n) in time
     * @param input: RandomArrayNumberString<number | string>
     * @param k: number
     * @private
     */

  }, {
    key: "_getSampleForObject",
    value: function _getSampleForObject(input, k) {
      // for objects
      var result = {},
          keys = Object.keys(input),
          n = keys.length,
          t = 0,
          // total elements
      m = 0; // selected elements

      _prngProxy["default"].random();

      while (m < k) {
        if ((n - t) * _prngProxy["default"].next() < k - m) {
          result[keys[t]] = input[keys[t]];
          m += 1;
        }

        t += 1;
      }

      return result;
    }
  }]);

  return Sample;
}(_base["default"]);

var _default = Sample;
exports["default"] = _default;