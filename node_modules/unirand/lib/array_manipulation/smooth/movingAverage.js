"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Moving average algorithm
 * options contain: weights ([0.125, 0.25, 0.25, 0.25, 0.125]), centerIndex: 3, policy: '2x4-MA'
 * Created by Alexey S. Kiselev
 */
var FLOAT_SUM = 10000;
var DEFAULT_MA_POLICY = '2x4-MA';

var MovingAverage = /*#__PURE__*/function () {
  function MovingAverage() {
    _classCallCheck(this, MovingAverage);

    this._defaultWeights = [0.125, 0.25, 0.25, 0.25, 0.125];
    this._policies = {
      '2x4-MA': {
        minDataLength: 5,
        weights: [0.125, 0.25, 0.25, 0.25, 0.125],
        centerIndex: 2
      },
      '2x12-MA': {
        minDataLength: 13,
        weights: [1 / 24, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 12, 1 / 24],
        centerIndex: 6
      },
      '2x8-MA': {
        minDataLength: 9,
        weights: [1 / 16, 1 / 8, 1 / 8, 1 / 8, 1 / 8, 1 / 8, 1 / 8, 1 / 8, 1 / 16],
        centerIndex: 4
      },
      '3x3-MA': {
        minDataLength: 5,
        weights: [1 / 9, 2 / 9, 1 / 3, 2 / 9, 1 / 9],
        centerIndex: 2
      },
      '3x5-MA': {
        minDataLength: 7,
        weights: [1 / 15, 2 / 15, 1 / 5, 1 / 5, 1 / 5, 2 / 15, 1 / 15],
        centerIndex: 3
      },
      '3-MA': {
        minDataLength: 3,
        weights: [1 / 3, 1 / 3, 1 / 3],
        centerIndex: 1
      },
      '5-MA': {
        minDataLength: 5,
        weights: [1 / 5, 1 / 5, 1 / 5, 1 / 5, 1 / 5],
        centerIndex: 2
      },
      'H5-MA': {
        minDataLength: 5,
        weights: [-0.073, 0.294, 0.558, 0.294, -0.073],
        centerIndex: 2
      },
      'H9-MA': {
        minDataLength: 9,
        weights: [-0.041, -0.01, 0.119, 0.267, 0.33, 0.267, 0.119, -0.01, -0.041],
        centerIndex: 4
      },
      'H13-MA': {
        minDataLength: 13,
        weights: [-0.019, -0.028, 0, 0.066, 0.147, 0.214, 0.240, 0.214, 0.147, 0.066, 0, -0.028, -0.019],
        centerIndex: 6
      },
      'H23-MA': {
        minDataLength: 23,
        weights: [-0.004, -0.011, -0.016, -0.015, -0.005, 0.013, 0.039, 0.068, 0.097, 0.122, 0.138, 0.148, 0.138, 0.122, 0.097, 0.068, 0.039, 0.013, -0.005, -0.015, -0.016, -0.011, -0.004],
        centerIndex: 11
      },
      'S15-MA': {
        minDataLength: 15,
        weights: [-0.009, -0.019, -0.016, 0.009, 0.066, 0.144, 0.209, 0.231, 0.209, 0.144, 0.066, 0.009, -0.016, -0.019, -0.009],
        centerIndex: 7
      },
      'S21-MA': {
        minDataLength: 21,
        weights: [-0.003, -0.009, -0.014, -0.014, -0.006, 0.017, 0.051, 0.037, 0.134, 0.163, 0.171, 0.163, 0.134, 0.037, 0.051, 0.017, -0.006, -0.014, -0.014, -0.009, -0.003],
        centerIndex: 10
      }
    };
  }
  /**
   * Smooth data
   * @param {RandomArray} data
   * @param {{[string]: any}} options
   */


  _createClass(MovingAverage, [{
    key: "smooth",
    value: function smooth(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var smoothData = this._getSmoothData(options || {});

      if (smoothData.minDataLength > data.length) {
        throw new Error("Smooth (Moving Average): data size must NOT be less then ".concat(smoothData.minDataLength, ", given ").concat(data.length));
      } // Smoothing implementation


      var result = [];
      var weights = smoothData.weights;
      var ci = smoothData.centerIndex;
      var leftStartIndex = smoothData.centerIndex;
      var rightEndIndex = data.length - 1 - (smoothData.weights.length - 1 - smoothData.centerIndex);
      var subResult; // Left edge case

      for (var i = 0; i < leftStartIndex; i += 1) {
        subResult = 0;

        for (var j = 0; j < weights.length; j += 1) {
          if (i + j - ci < 0) {
            subResult += data[Math.abs(i + j - ci) - 1] * weights[j];
          } else {
            subResult += data[i + j - ci] * weights[j];
          }
        }

        result[i] = subResult;
      } // Centered smooth - leftStartIndex <= i <= rightEndIndex


      for (var _i = leftStartIndex; _i <= rightEndIndex; _i += 1) {
        subResult = 0;

        for (var _j = 0; _j < weights.length; _j += 1) {
          subResult += data[_i + _j - ci] * weights[_j];
        }

        result[_i] = subResult;
      } // Right edge case


      for (var _i2 = rightEndIndex + 1; _i2 < data.length; _i2 += 1) {
        subResult = 0;

        for (var _j2 = 0; _j2 < weights.length; _j2 += 1) {
          if (_i2 + _j2 - ci >= data.length) {
            subResult += data[2 * data.length - (_i2 + _j2 - ci + 1)] * weights[_j2];
          } else {
            subResult += data[_i2 + _j2 - ci] * weights[_j2];
          }
        }

        result[_i2] = subResult;
      }

      return result;
    }
    /**
     * Construct weights and other data from options
     * @param {{[string]: any}} options
     * @private
     */

  }, {
    key: "_getSmoothData",
    value: function _getSmoothData(options) {
      // priority for policies
      if (this._isDefined(options.policy)) {
        if (!this._policies[options.policy]) {
          throw new Error("Smooth (Moving Average): policy ".concat(options.policy, " not allowed"));
        }

        return this._policies[options.policy];
      } // second priority for weights


      if (this._isDefined(options.weights)) {
        this._checkWeightsSum(options.weights);

        if (this._isDefined(options.centerIndex)) {
          this._checkCenterIndex(options.weights, options.centerIndex);

          return {
            minDataLength: options.weights.length,
            weights: options.weights,
            centerIndex: options.centerIndex
          };
        } else {
          return this._constructSmoothDataFromWeights(options.weights);
        }
      } // third priority for order


      if (this._isDefined(options.order)) {
        this._checkOrder(options.order); // construct weights from order


        var tempWeights = [];
        var tempOrder = Math.floor(Number(options.order));

        for (var i = 0; i < tempOrder; i += 1) {
          tempWeights[i] = 1 / tempOrder;
        }

        if (options.centered) {
          return this._constructSmoothDataFromWeights(tempWeights);
        }

        return {
          minDataLength: tempOrder,
          weights: tempWeights,
          centerIndex: Math.floor(tempOrder / 2)
        };
      }

      return this._policies[DEFAULT_MA_POLICY];
    }
    /**
     * Constructs smooth data from weights
     * @param {Array<number>} weights
     * @returns {MASmoothData}
     * @private
     */

  }, {
    key: "_constructSmoothDataFromWeights",
    value: function _constructSmoothDataFromWeights(weights) {
      if (weights.length % 2 === 1) {
        return {
          weights: weights,
          minDataLength: weights.length,
          centerIndex: Math.floor(weights.length / 2)
        };
      } // Extend weights with centered weight equals to 0


      var extendedWeights = [];

      for (var i = 0; i < weights.length / 2; i += 1) {
        extendedWeights[i] = weights[i];
      }

      extendedWeights[weights.length / 2] = 0;

      for (var _i3 = weights.length / 2; _i3 < weights.length; _i3 += 1) {
        extendedWeights[_i3 + 1] = weights[_i3];
      }

      return {
        weights: extendedWeights,
        minDataLength: extendedWeights.length,
        centerIndex: weights.length / 2
      };
    }
    /**
     * Checks whether options has field
     * @param {number} field
     * @returns {boolean}
     * @private
     */

  }, {
    key: "_isDefined",
    value: function _isDefined(field) {
      return typeof field !== 'undefined' && field !== null;
    }
    /**
     * Checks whether the order is good
     * @param {any} order
     * @private
     */

  }, {
    key: "_checkOrder",
    value: function _checkOrder(order) {
      if (!Number(order) || Math.floor(Number(order)) < 2) {
        throw new Error('Smooth (Moving Average): options.order must be an positive integer number > 1');
      }
    }
    /**
     * Checks whether options.centerIndex is good
     * @param {Array<number>} weights
     * @param {any} centerIndex
     * @private
     */

  }, {
    key: "_checkCenterIndex",
    value: function _checkCenterIndex(weights, centerIndex) {
      if (Number(centerIndex) === 0) {
        return;
      }

      if (!Number(centerIndex)) {
        throw new Error('Smooth (Moving Average): options.centerIndex must be an integer number');
      }

      var centerIndexAsNumber = Math.floor(Number(centerIndex));

      if (centerIndexAsNumber < 0 || centerIndexAsNumber >= weights.length) {
        throw new Error('Smooth (Moving Average): options.centerIndex must be 0 <= centerIndex < options.weights.length');
      }
    }
    /**
     * Checks whether sum of weights equals one (1.0001 is not OK, but 1.00001 is OK)
     * @param {any} weights
     * @private
     */

  }, {
    key: "_checkWeightsSum",
    value: function _checkWeightsSum(weights) {
      if (!Array.isArray(weights)) {
        throw new Error('Smooth (Moving Average): options.weights must be an array');
      }

      var sum = 0;

      for (var i = 0; i < weights.length; i += 1) {
        sum += weights[i];
      }

      if (Math.round(sum * FLOAT_SUM) !== FLOAT_SUM) {
        throw new Error("Smooth(Moving Average): sum of weights must be 1, given ".concat(sum));
      }
    }
    /**
     * @returns {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return 'Moving Average';
    }
  }]);

  return MovingAverage;
}();

var _default = MovingAverage;
exports["default"] = _default;