"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RippleBase58 = exports.FlickrBase58 = exports.BitcoinBase58 = void 0;

var _commonEncoder = _interopRequireDefault(require("./commonEncoder"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var ALLOWED_ALPHABETS = {
  'bitcoin-base58': '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  'flickr-base58': '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
  'ripple-base58': 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'
};
var ALPHABET_LENGTH = 58;

var CommonBase58 = /*#__PURE__*/function (_CommonEncoder) {
  _inherits(CommonBase58, _CommonEncoder);

  var _super = _createSuper(CommonBase58);

  function CommonBase58(alphabet) {
    var _this;

    _classCallCheck(this, CommonBase58);

    _this = _super.call(this);

    _this.setAlphabet(alphabet);

    _this._createCodesMap();

    return _this;
  }

  _createClass(CommonBase58, [{
    key: "setAlphabet",
    value: function setAlphabet(alphabet) {
      if (!ALLOWED_ALPHABETS[alphabet]) {
        throw new Error("Base58 encoder: alphabet ".concat(alphabet, " is not allowed"));
      }

      this._alphabet = ALLOWED_ALPHABETS[alphabet];
    }
  }, {
    key: "_createCodesMap",
    value: function _createCodesMap() {
      this._codesMap = {};

      for (var i = 0; i < this._alphabet.length; i += 1) {
        this._codesMap[this._alphabet[i]] = i;
      }
    }
  }, {
    key: "_getCodesMap",
    value: function _getCodesMap() {
      return this._codesMap;
    }
  }, {
    key: "encodeFromByteArray",
    value: function encodeFromByteArray(bytes) {
      var indexes = [0];
      var carry;

      for (var i = 0; i < bytes.length; i += 1) {
        carry = (indexes[0] << 8) + bytes[i];
        indexes[0] = carry % ALPHABET_LENGTH;
        carry = Math.floor(carry / ALPHABET_LENGTH);

        for (var j = 1; j < indexes.length; j += 1) {
          carry += indexes[j] << 8;
          indexes[j] = carry % ALPHABET_LENGTH;
          carry = Math.floor(carry / ALPHABET_LENGTH);
        }

        while (carry > 0) {
          indexes.push(carry % ALPHABET_LENGTH);
          carry = Math.floor(carry / ALPHABET_LENGTH);
        }
      } // leading zeros


      for (var _i = 0; bytes[_i] === 0 && _i < bytes.length - 1; _i += 1) {
        indexes.push(0);
      } // reverse indexes and build the string


      var temp_letter;

      for (var _i2 = 0, _j = indexes.length - 1; _i2 <= _j; _i2 += 1, _j -= 1) {
        temp_letter = this._alphabet[indexes[_i2]];
        indexes[_i2] = this._alphabet[indexes[_j]];
        indexes[_j] = temp_letter;
      }

      return indexes.join('');
    }
  }, {
    key: "decodeToByteArray",
    value: function decodeToByteArray(str) {
      var res = [0];
      var letterIndex;
      var carry;

      for (var i = 0; i < str.length; i += 1) {
        if (!this._getCodesMap()[str[i]]) {
          if (str[i] !== this._alphabet[0]) {
            throw new Error('Base58 decode: invalid input');
          }
        }

        letterIndex = this._getCodesMap()[str[i]];
        carry = res[0] * ALPHABET_LENGTH + letterIndex;
        res[0] = carry & 0xFF;
        carry >>= 8;

        for (var j = 1; j < res.length; j += 1) {
          carry += res[j] * ALPHABET_LENGTH;
          res[j] = carry & 0xFF;
          carry >>= 8;
        }

        while (carry > 0) {
          res.push(carry & 0xFF);
          carry >>= 8;
        }
      } // leading zeros


      for (var _i3 = 0; str[_i3] === this._alphabet[0] && _i3 < str.length - 1; _i3 += 1) {
        res.push(0);
      }

      return res.reverse();
    }
  }]);

  return CommonBase58;
}(_commonEncoder["default"]);

var BitcoinBase58 = /*#__PURE__*/function (_CommonBase) {
  _inherits(BitcoinBase58, _CommonBase);

  var _super2 = _createSuper(BitcoinBase58);

  function BitcoinBase58() {
    _classCallCheck(this, BitcoinBase58);

    return _super2.call(this, 'bitcoin-base58');
  }

  return BitcoinBase58;
}(CommonBase58);

exports.BitcoinBase58 = BitcoinBase58;

var FlickrBase58 = /*#__PURE__*/function (_CommonBase2) {
  _inherits(FlickrBase58, _CommonBase2);

  var _super3 = _createSuper(FlickrBase58);

  function FlickrBase58() {
    _classCallCheck(this, FlickrBase58);

    return _super3.call(this, 'flickr-base58');
  }

  return FlickrBase58;
}(CommonBase58);

exports.FlickrBase58 = FlickrBase58;

var RippleBase58 = /*#__PURE__*/function (_CommonBase3) {
  _inherits(RippleBase58, _CommonBase3);

  var _super4 = _createSuper(RippleBase58);

  function RippleBase58() {
    _classCallCheck(this, RippleBase58);

    return _super4.call(this, 'ripple-base58');
  }

  return RippleBase58;
}(CommonBase58);

exports.RippleBase58 = RippleBase58;