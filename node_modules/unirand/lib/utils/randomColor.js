"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _interfaces = require("../interfaces");

var _decorators = require("../decorators");

var _prngProxy = _interopRequireDefault(require("../prng/prngProxy"));

var _class;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RandomColor = (0, _decorators.Singleton)(_class = /*#__PURE__*/function () {
  // v t p q
  function RandomColor(saturation) {
    _classCallCheck(this, RandomColor);

    this.setSaturation(saturation);
    this._goldenRatioConjugate = 0.618033988749895;
    this._hMap = {
      // $FlowFixMe
      0: [0, 1, 2],
      // $FlowFixMe
      1: [3, 0, 2],
      // $FlowFixMe
      2: [2, 0, 1],
      // $FlowFixMe
      3: [2, 3, 0],
      // $FlowFixMe
      4: [1, 2, 0],
      // $FlowFixMe
      5: [0, 2, 3]
    }; // v t p q

    this._transformMap = {
      'rgb': this._transformRGB,
      'hex': this._transformHex.bind(this)
    };
  }
  /**
   * Returns allowed types of transformations
   * @returns {{hex: boolean, rgb: boolean}}
   */


  _createClass(RandomColor, [{
    key: "getSaturation",

    /**
     * @returns {number}
     * @public
     */
    value: function getSaturation() {
      return this._saturation;
    }
    /**
     * @param {number} saturation
     * @public
     */

  }, {
    key: "setSaturation",
    value: function setSaturation(saturation) {
      this._validateSaturation(Number(saturation));

      this._saturation = Number(saturation);
    }
    /**
     * Validates saturation
     * @param {number} saturation
     * @private
     */

  }, {
    key: "_validateSaturation",
    value: function _validateSaturation(saturation) {
      if (!((saturation || saturation === 0) && saturation >= 0 && saturation <= 1)) {
        throw new Error('RandomColor: saturation must be in 0 <= saturation <= 1 range');
      }
    }
    /**
     * Converts HSV to RGB
     * @param h
     * @param s
     * @param v
     * @private
     */

  }, {
    key: "_hsvToRgb",
    value: function _hsvToRgb(h, s, v) {
      var hInt = Math.floor(h * 6);
      var f = h * 6 - hInt;
      var p = v * (1 - s);
      var q = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      return this._rgbFromVtpq(this._hMap[hInt], [v, t, p, q]);
    }
    /**
     * @returns {Array<number>}
     * @private
     */

  }, {
    key: "_rgbFromVtpq",
    value: function _rgbFromVtpq(rgbMap, vtpq) {
      return [Math.floor(vtpq[rgbMap[0]] * 256), Math.floor(vtpq[rgbMap[1]] * 256), Math.floor(vtpq[rgbMap[2]] * 256)];
    }
    /**
     * Generates random color
     * @returns {Array<number>} rgb array
     * @private
     */

  }, {
    key: "_randomColor",
    value: function _randomColor() {
      return this._hsvToRgb(this._randomH(_prngProxy["default"].random()), this._saturation, this._getRandomV());
    }
    /**
     * Generates random color or array of colors
     * Output depends on type
     * @param {string} type
     * @param {number} n
     * @public
     */

  }, {
    key: "randomColor",
    value: function randomColor(type) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      if (n <= 0) {
        return this._transform(type)(this._randomColor());
      }

      _prngProxy["default"].random();

      var res = [];

      for (var i = 0; i < n; i += 1) {
        res[i] = this.nextColor(type);
      }

      return res;
    }
    /**
     * Generates random color
     * @returns {Array<number>} rgb array
     * @private
     */

  }, {
    key: "_nextColor",
    value: function _nextColor() {
      return this._hsvToRgb(this._randomH(_prngProxy["default"].next()), this._saturation, this._getRandomV());
    }
  }, {
    key: "_getRandomV",
    value: function _getRandomV() {
      return 0.7 + 0.3 * _prngProxy["default"].next();
    }
    /**
     * Generates random color or array of colors
     * Output depends on type
     * @param {string} type
     * @public
     */

  }, {
    key: "nextColor",
    value: function nextColor(type) {
      return this._transform(type)(this._nextColor());
    }
    /**
     * Returns random hue value
     * @param {number} rand
     * @returns {number}
     * @private
     */

  }, {
    key: "_randomH",
    value: function _randomH(rand) {
      var _h = rand + this._goldenRatioConjugate;

      return _h % 1;
    }
    /**
     * Transforms RGB array due to type
     * @param {string} type
     * @private
     */

  }, {
    key: "_transform",
    value: function _transform(type) {
      return this._transformMap[type];
    }
  }, {
    key: "_transformRGB",
    value: function _transformRGB(rgb) {
      return rgb;
    }
  }, {
    key: "_transformHex",
    value: function _transformHex(rgb) {
      return '#' + this._componentToHex(rgb[0]) + this._componentToHex(rgb[1]) + this._componentToHex(rgb[2]);
    }
  }, {
    key: "_componentToHex",
    value: function _componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }
  }], [{
    key: "getTypes",
    value: function getTypes() {
      return {
        'rgb': true,
        'hex': true
      };
    }
  }]);

  return RandomColor;
}()) || _class;

var _default = RandomColor;
exports["default"] = _default;