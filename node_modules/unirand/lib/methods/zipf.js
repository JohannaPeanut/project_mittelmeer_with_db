"use strict";

var _prngProxy = _interopRequireDefault(require("../prng/prngProxy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Zipf = /*#__PURE__*/function () {
  function Zipf(alpha, shape) {
    _classCallCheck(this, Zipf);

    this.alpha = Number(alpha);
    this.shape = Math.floor(Number(shape));
    this._harmonicAlphaMinusOne = null;
    this._harmonicAlphaMinusTwo = null;

    if (isNaN(this.alpha) || isNaN(this.shape)) {
      return;
    }

    this._init();
  }
  /**
   * Initialization
   * Generates harmonics
   * @private
   */


  _createClass(Zipf, [{
    key: "_init",
    value: function _init() {
      this._harmonics = [];
      this._c = 0;
      this._sumProbs = [0];

      this._generate_harmonics();
    }
    /**
     * Generates harmonics up to <shape>
     * @private
     */

  }, {
    key: "_generate_harmonics",
    value: function _generate_harmonics() {
      if (this.shape <= this._harmonics.length) {
        return;
      }

      var harmonicsLength = this._harmonics.length;
      var temp;

      for (var i = harmonicsLength + 1; i <= this.shape; i += 1) {
        temp = Math.pow(i, this.alpha);
        this._c = this._c + 1 / temp;
        this._harmonics[i - 1] = this._c;
        this._sumProbs[i] = this._sumProbs[i - 1] + 1 / temp;
      }
    }
    /**
     * Generates harmonics for shifted <alpha>
     * @param {number} shift
     * @private
     */

  }, {
    key: "_generate_harmonic_shifted_alpha",
    value: function _generate_harmonic_shifted_alpha(shift) {
      var _c = 0;

      for (var i = 1; i <= this.shape; i += 1) {
        _c = _c + 1 / Math.pow(i, this.alpha - shift);
      }

      return _c;
    }
    /**
     * Generates single random value, O(log(shape)) time complexity
     * @param {number} u
     * @return {number}
     * @private
     */

  }, {
    key: "_random",
    value: function _random(u) {
      var low = 0,
          high = this.shape,
          mid,
          zipfValue,
          normalize = this._harmonics[this.shape - 1];

      do {
        mid = Math.floor(0.5 * (low + high));

        if (this._sumProbs[mid] / normalize >= u && this._sumProbs[mid - 1] / normalize < u) {
          zipfValue = mid;
          break;
        } else if (this._sumProbs[mid] / normalize >= u) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      } while (low <= high);

      return zipfValue;
    }
    /**
     * Generates uniformly distributed value, but not 0 and 1
     * @private
     */

  }, {
    key: "_generate_uniform_random",
    value: function _generate_uniform_random() {
      var u = 0;

      while (u === 0 || u === 1) {
        u = _prngProxy["default"].random();
      }

      return u;
    }
    /**
     * Generates uniformly distributed value, but not 0 and 1
     * @private
     */

  }, {
    key: "_generate_uniform_next",
    value: function _generate_uniform_next() {
      var u = 0;

      while (u === 0 || u === 1) {
        u = _prngProxy["default"].next();
      }

      return u;
    }
    /**
     * Generates a random number
     * @returns {number} a Zipf distributed number
     */

  }, {
    key: "random",
    value: function random() {
      return this._random(this._generate_uniform_random());
    }
    /**
     * Generates next seeded random number
     * @returns {number} a Zipf distributed number
     */

  }, {
    key: "next",
    value: function next() {
      return this._random(this._generate_uniform_next());
    }
    /**
     * Generates Zipf distributed numbers
     * @param n: number - Number of elements in resulting array, n > 0
     * @returns Array<number> - Zipf distributed numbers
     */

  }, {
    key: "distribution",
    value: function distribution(n) {
      var zipfArray = [],
          random = _prngProxy["default"].random(n);

      for (var i = 0; i < n; i += 1) {
        zipfArray[i] = this._random(random[i]);
      }

      return zipfArray;
    }
    /**
     * Error handling
     * @returns {boolean}
     */

  }, {
    key: "isError",
    value: function isError() {
      if (isNaN(this.alpha) || isNaN(this.shape)) {
        return {
          error: 'Zipf distribution: you should point "alpha" and "shape" numerical values'
        };
      }

      if (this.alpha < 0) {
        return {
          error: 'Zipf distribution: parameters "alpha" must be >= 0'
        };
      }

      if (this.shape <= 1) {
        return {
          error: 'Zipf distribution: parameters "shape" must be > 1'
        };
      }

      return {
        error: false
      };
    }
    /**
     * Refresh method
     * @param newAlpha: number - new parameter "alpha"
     * @param newShape: number - new parameter "shape"
     * This method does not return values
     */

  }, {
    key: "refresh",
    value: function refresh(newAlpha, newShape) {
      // refresh is expensive - avoid refreshing for the same <alpha> and <shape> values
      if (this.alpha === newAlpha && this.shape === newShape) {
        return;
      }

      this._harmonicAlphaMinusOne = null; // need to recalculate after refresh

      this._harmonicAlphaMinusTwo = null; // need to recalculate after refresh

      this.shape = Math.floor(Number(newShape));

      if (this.alpha === newAlpha && !isNaN(this.shape)) {
        // do not recalculate everything
        this._generate_harmonics();

        return;
      } // recalculate all harmonics


      this.alpha = Number(newAlpha);

      if (isNaN(this.alpha) || isNaN(this.shape)) {
        return;
      }

      this._init();
    }
    /**
     * Class .toString method
     * @returns {string}
     */

  }, {
    key: "toString",
    value: function toString() {
      var info = ['Zipf Distribution', "Usage: unirand.zipf(".concat(this.alpha, ", ").concat(this.shape, ").random()")];
      return info.join('\n');
    }
    /**
     * Mean value
     * Information only
     * For calculating real mean value use analyzer
     */

  }, {
    key: "mean",
    get: function get() {
      if (this._harmonicAlphaMinusOne === null) {
        this._harmonicAlphaMinusOne = this._generate_harmonic_shifted_alpha(1);
      }

      return this._harmonicAlphaMinusOne / this._harmonics[this.shape - 1];
    }
    /**
     * Mode value - value, which appears most often
     * Information only
     * For calculating real mode value use analyzer
     */

  }, {
    key: "mode",
    get: function get() {
      return 1;
    }
    /**
     * Variance value
     * Information only
     * For calculating real variance value use analyzer
     */

  }, {
    key: "variance",
    get: function get() {
      if (this._harmonicAlphaMinusTwo === null) {
        this._harmonicAlphaMinusTwo = this._generate_harmonic_shifted_alpha(2);
      }

      return this._harmonicAlphaMinusTwo / this._harmonics[this.shape - 1] - Math.pow(this.mean, 2);
    }
    /**
     * Entropy value
     * Information only
     * For calculating real entropy value use analyzer
     */

  }, {
    key: "entropy",
    get: function get() {
      var _c = 0;

      for (var i = 1; i <= this.shape; i += 1) {
        _c += Math.log(i) / Math.pow(i, this.alpha);
      }

      return Math.log(this._harmonics[this.shape - 1]) + this.alpha * _c / this._harmonics[this.shape - 1];
    }
    /**
     * All parameters of distribution in one object
     * Information only
     */

  }, {
    key: "parameters",
    get: function get() {
      return {
        mean: this.mean,
        mode: this.mode,
        variance: this.variance,
        entropy: this.entropy
      };
    }
  }]);

  return Zipf;
}();

module.exports = Zipf;