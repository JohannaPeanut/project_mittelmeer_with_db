"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Singleton = Singleton;
exports.AnalyzerSingleton = exports.AnalyzerPublicFunction = exports.AnalyzerPublicMethod = void 0;

var _interfaces = require("./interfaces");

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Decorator for making method public for AnalyzerFactory
 * I this decorator I am going to check publicMethods property
 * If this object does not exist - create empty object
 * Then add name of public method to this object via propertyKey value
 * In class add @PublicMethod string before every public method
 */
var AnalyzerPublicMethod = function AnalyzerPublicMethod(Target, propertyKey) {
  if (!Target.constructor.publicMethods) {
    Target.constructor.publicMethods = {};
  }

  Target.constructor.publicMethods[propertyKey] = 1;
};

exports.AnalyzerPublicMethod = AnalyzerPublicMethod;

var AnalyzerPublicFunction = function AnalyzerPublicFunction(Target, propertyKey) {
  if (!Target.constructor.publicFunctions) {
    Target.constructor.publicFunctions = {};
  }

  Target.constructor.publicFunctions[propertyKey] = 1;
};

exports.AnalyzerPublicFunction = AnalyzerPublicFunction;

var AnalyzerSingleton = function AnalyzerSingleton(Target) {
  /**
   * Create instance object initially assigned to null
   */
  Target._instance = null;
  /**
   * Add static method getInstance to target
   * Instead of using "new" keyword I use getInstance method
   */

  Object.assign(Target, {
    getInstance: function getInstance() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /**
       * If instance haven't created - create it with arguments
       * If instance created - update params via calling constructor without creating new object
       * In total returns instance
       */
      if (!Target._instance) {
        Target._instance = _construct(Target, args);
      } else {
        Target._instance.constructor.apply(Target._instance, args);
      }

      return Target._instance;
    }
  });
};

exports.AnalyzerSingleton = AnalyzerSingleton;

function Singleton(Target) {
  /**
   * Create instance object initially assigned to null
   */
  Target._instance = null;
  /**
   * Add static method getInstance to target
   * Instead of using "new" keyword I use getInstance method
   */

  Object.defineProperty(Target, 'getInstance', {
    value: function value() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      /**
       * If instance haven't created - create it with arguments
       * If instance created - update params via calling constructor without creating new object
       * In total returns instance
       */
      if (!Target._instance) {
        Target._instance = _construct(Target, args);
      } else {
        Target._instance.constructor.apply(Target._instance, args);
      }

      return Target._instance;
    }
  });
}